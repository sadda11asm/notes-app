{"version":3,"sources":["../../server/services/UserService.js"],"names":["require","config","redis","expiration_time","UserService","new_user","next","database","User","findOne","where","username","prev_user","Error","salt","argon2","hash","password","hashed_password","toString","token","jwt","sign","process","env","JWT_SECRET","expiresIn","create","db_user","user_res","JSON","parse","stringify","Reflect","deleteProperty","console","log","user","verify","valid_password","message","res","port_redis","PORT","redis_client","createClient","set","expire"],"mappings":"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","sourcesContent":["import database from '../models';\nimport { randomBytes } from 'crypto';\nrequire('dotenv').config();\nimport argon2 from 'argon2';\nimport jwt from 'jsonwebtoken';\nconst redis = require('redis');\n\nconst expiration_time = 86400;\n\n\nclass UserService {\n    static async signUp(new_user, next) {\n        try {\n            const prev_user = await database.User.findOne({\n                where: {username : new_user.username}\n            })\n            if (prev_user) {\n                next(new Error(\"Choose another username\"), true)\n                return\n            }\n            const salt = randomBytes(32);\n            const hashed_password = await argon2.hash(new_user.password, { salt });\n            new_user.password = hashed_password;\n            new_user.salt = salt.toString()\n            let token = jwt.sign({username: new_user.username},\n                process.env.JWT_SECRET, { \n                    expiresIn: '24h' // expires in 24 hours\n                }\n            );\n            const db_user = await database.User.create(new_user);\n            let user_res =  JSON.parse(JSON.stringify(db_user))\n            user_res.token = token\n            Reflect.deleteProperty(user_res, 'password');\n            Reflect.deleteProperty(user_res, 'salt');\n            next(null, false, user_res)\n        } catch (error) {\n            console.log(error)\n            next(error, false)\n        }\n    }\n\n    static async logIn(user, next) {\n        try {\n            const db_user = await database.User.findOne({\n                where: {username : user.username}\n            })\n            if (!db_user) {\n                next(Error(\"Incorrect username\"), true)\n                return\n            }\n            const valid_password = await argon2.verify(db_user.password, user.password);\n            if (valid_password) {\n                let token = jwt.sign({username: user.username},\n                    process.env.JWT_SECRET,\n                    { \n                        expiresIn: '24h' // expires in 24 hours\n                    }\n                );\n                let user_res =  JSON.parse(JSON.stringify(user))\n                user_res.token = token\n                Reflect.deleteProperty(user_res, 'password');\n                next(null, false, user_res)\n            } else {\n                next(Error(\"Incorrect password\"), true)\n            }\n        } catch (error) {\n            console.log(error.message)\n            res(new Error(error.message), false)\n        }\n    }\n\n    static async logOut(token, username, next) {\n        try {\n            const port_redis = process.env.PORT || 6379;\n            const redis_client = redis.createClient(port_redis);\n            // add to blacklist of tokens\n            await redis_client.set(token, username);\n            await redis_client.expire(token, expiration_time)\n            // console.log(set)\n            next()\n        } catch (error) {\n            console.log(error)\n            next(error, false)\n        }\n    }\n\n    // static async clean_cache(username, redis_client) {\n    //     const end = Date.now()\n    //     var d = Date.parse(end)\n    //     const expiredTokens = await redis_client.zrangebyscore(`${username}-tokens`, `-inf`, d);\n\n    //     expiredTokens.length >= 1 && expiredTokens.forEach(async token => {\n    //         await redis.zrem(`${username}-tokens`, token)\n    //     });\n    // }\n\n//   static async getABook(id) {\n//     try {\n//       const theBook = await database.Book.findOne({\n//         where: { id: Number(id) }\n//       });\n\n//       return theBook;\n//     } catch (error) {\n//       throw error;\n//     }\n//   }\n\n//   static async deleteBook(id) {\n//     try {\n//       const bookToDelete = await database.Book.findOne({ where: { id: Number(id) } });\n\n//       if (bookToDelete) {\n//         const deletedBook = await database.Book.destroy({\n//           where: { id: Number(id) }\n//         });\n//         return deletedBook;\n//       }\n//       return null;\n//     } catch (error) {\n//       throw error;\n//     }\n//   }\n}\n\nexport default UserService;"],"file":"UserService.js"}